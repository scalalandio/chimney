# Architectural Decision Record

## 1.4.0 and before

Since ADR was introduced after the 1.4.0 release, this is only the best effort explaining some of the designs that we
ended up with.

### Derivation is automatically recursive

**Status**: adopted

**Context**: what should be the behavior: should it work more like e.g. Circe codec derivation - hard division between
automatic derivation (with recursion) and semi-automatic derivation (without recursion) - or inspirec by Jsoniter Scala
- which has semiautomatic derivation only, but it can be recursive.

**Decision**:

When deriving both automatic and semiautomatic  conversion from `Source` type into `Target` type, we would
automatically derive:

 * conversion from `Source.fieldName` into `Target.fieldName` (when field names are matched, `Target` has a public
   constructor, etc)
 * conversion from `SourceSubtype <: Source` into `TargetSubtype <: Target` (when subtypes names are matched, both
   are `sealed` hierarchies, etc)
 * conversions for collections' items' types when converting between collections, etc

until it would reach conversion between `Source <: Target` or conversion for which there is user-provided implicit
(`Partial`)`Transformer` instance.

This is closer in behavior to Jsoniter Scala, but differs from it in that it allows also automatic derivation.

**Consequences**:

DSL is easier to use out-of-the-box for the most common cases. However, NOT using automatic derivation becomes
an opt-out that we have to allow.

**See**:

 * [Automatic, Semiautomatic and Inlined derivation](cookbook.md#automatic-semiautomatic-and-inlined-derivation) - how
   we currently separate main DSL, and allow for opt-in automatic/inlined/syntax imports 

### Strategy of code generation

**Status**: adopted

**Context**: what should be the strategy of code generation by Chimney: should it work like e.g. Circe when every little
piece of behavior requires a separate type class instance, and everything is combined via Shapeless/Magnolia or should
we use handwritten macros.

**Decision**:

The flexibility we need makes it very hard to create the code using tools like Shapeless/Magnolia. The compile-time
complexity grew up so big that e.g. single file with conversion of 22 fields in one class into another took over 2
minutes (an anecdote from my experience). At the same time mental overhead of the maintenance was quite huge so it
pushed us towards handwritten macros.

Additionally, Chimney might be used by both people that don't care about the performance AND by the people who DO care,
we should make the code performant. One of the most important way of achieving it, is avoiding unnecessary allocations:

This is what typical automatic derivation generate:

```scala
case class Foo(a: Int, b: String)
case class Bar(a: Int, b: String)

val foo: Foo = new Foo(a = 10, b = "aa")

// what would be generated by the typical automatic derivation
val bar = new Transformer[Foo, Bar] {
  def transform(src: Foo): Bar = {
    new Bar(
      a = Transformer.identity.transform(foo.a),
      b = Transformer.identity.transform(foo.a)
    )
  }
}.transform(bar)
```

Since we are using macros, it's hard to justify this cost when instead we can generate:

```scala
case class Foo(a: Int, b: String)
case class Bar(a: Int, b: String)

val foo: Foo = new Foo(a = 10, b = "aa")

// What would be generated by foo.transformInto[Bar]:
val bar = new Transformer[Foo, Bar] {
  def transform(src: Foo): Bar = {
    new Bar(
      a = src.a,
      b = src.a
    )
  }
}.transform(bar)
// (transformInto summons a type class so ONE type class instance is necessary)

// What would be generated by foo.into[Bar].transform
val bar2 = new Bar(
  a = foo.a,
  b = foo.a
)
// (into.transform expands a macro directly, so type class is called only if there was one already in scope).
```

For the same reason `PartialTransformer`s defer wrapping result in `partial.Result` as long as possible - if there was 
no transformation that would parse the source value (unwrapping `Option`, implicit, `withFieldConstPartial`, ...) it
would wrap only once, right before returning the value:

```scala
// What would be generated by foo.transformIntoPartial[Bar] when Partials wouldn't be actually needed:
val bar = new PartialTransformer[Foo, Bar] {
  def transform(src: Foo): Bar = {
    partial.Result.Value(
      new Bar(
        a = src.a,
        b = src.a
      )
    )
  }
}.transform(bar)
```

All in all, we decided to implement the derivation using macros outputting optimized code.

**Consequences**:

Codebase looks like something harder to contribute to (even though it is much easier to work with than Shapeless-based
code attempting to achieve the same thing). The resulting code is fast, BUT since all the work happens in a macro
the burden on providing API for extending the behavior is on us. Without it, users could at best provide the complete
instances which would not be aware of our whole DSL.

**See**:

 * [Integrations](cookbook.md#integrations) - to see how we designed the API to allow integrating with Chimney in
   a different way than just implicits with a `Transformer` instances

### Separation of `Transformer` and `Transformer.AutoDerived`

**Status**: adopted

**Context**: we need to allow users to override the behavior with implicit `Transformer` instances. At the same time
we DO NOT want to consider `Transformer`s generated by Chimney automatic derivation, since it would kill any benefits of
using recursive derivation that avoids instantiation. Therefore, we need to somehow discriminate between instances
provides by users and instances provided by Chimney itself.

Prior to 0.8.x we achieved that by summoning the type class, checking its tree to see if it was generated by Chimney's
macro and discarding it in such case... which resulted in exponential time (every branch generated a tree which was
discarded right after derivation... and each such branch was probably discarding its own branches, etc). 

**Decision**:

We decided to keep 2 separate types: `Transformer` and `Transformer.AutoDerived`.

`Transformer` is intended to be implemented by users OR derived semiautomatically with `Transformer.derive`.

`Transformer.AutoDerived` is intended to be summoned by `.transformInto` in the absence of `Transformer` and only then.

To make it possible we have to make `Transformer <: Transformer.AutoDerived` and arrange implicit priorities
accordingly.

**Consequences**:

TODO
