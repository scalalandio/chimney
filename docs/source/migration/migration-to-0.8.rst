Migration to 0.8.x
==================

Version 0.8.0 is is the first version which cleaned up the API. It introduced
several breaking changes:

- lifted transformers, deprecated in 0.7.0, got removed in favor of partial
  transformers. Since 0.7.0 migration guide from lifted to partial is available
  in ``partial transformers`` migrating from :ref:`lifted section<migrating-from-lifted>`.
- ``.enableUnsafeOption`` option was removed - if ``Option`` unwrapping is
  needed, it is recommended to use :ref:`partial transformers<partial-transformers>`
- types returned by automatic derivation got split from types that are used
  for user-provided transformations and configured (semiautomatic) derivation:
  ``Transformer`` got split into ``Transformer`` and ``Transformer.AutoDerived``
  while ``PartialTransformer`` got split into ``PartialTransformer`` and
  ``PartialTransformer.AutoDerived``.

  It was caused be the change in mechanism for recursive derivation: since it
  avoid boxing and allocation where possible, it used to check if summoned
  implicit was generated by automatic derivation. If it came from
  ``Transformer.derive`` or ``PartialTransformer.derive`` it was discarded and
  macro attempted to derive it again without wrapping result in a type class.

  It both complicated code as well as increased compilation times as each field
  or subtype would attempt to summon implicit and then discard it if it didn't
  came from user. Splitting types allows compiler to not summon any implicit if
  user haven't provided any.

  The consequence is only visible if there is some ``implicit def`` which takes
  another implicit ``Transformer``.

  .. code-block:: scala

    class MyType[A](private val a: A) {
      def map[B](f: A => B): MyType[B] =
        new MyType(f(a))
    }

    implicit def provideMyType[A, B](
      implicit a2b: Transformer[A, B]
    ): Transformer[MyType[A], MyType[B]] =
      myA => myA.map(_.transformInto[B])

  After changes in 0.8.x ``implicit Transformer[A, B]`` means "instance provided by user",
  either manually or through semiautomatic derivation. If users want to allow summoning
  there automatic instances as well, they need to use ``Transformer.AutoDerived``:

  .. code-block:: scala

    class MyOtherType[A](private val a: A) {
      def map[B](f: A => B): MyOtherType[B] =
        new MyOtherType(f(a))
    }

    implicit def provideMyOtherType[A, B](
      implicit a2b: Transformer.AutoDerived[A, B]
    ): Transformer[MyOtherType[A], MyOtherType[B]] =
      myA => myA.map(_.transformInto[B])

  which would summon both automatically derived instances as well as manually provided.
  The difference is shown in this example:

  .. code-block:: scala

    // implicit provided by user
    implicit val int2str: Transformer[Int, String] = _.toString

    val myType: MyType[Int] = new MyType(10)
    val myOtherType: MyOtherType[Int] = new MyOtherType(10)

    // uses provideMyType(int2str):
    myType.transformInto[MyType[String]]

    // uses provideMyOtherType(int2str):
    myOtherType.transformInto[MyOtherType[String]

    val myType2: MyType[Either[Int, Int]] = new MyType(Right(10))
    val myOtherType2: MyOtherType[Either[Int, Int]] = new MyOtherType(Right(10)

    // requires manually provided transformer e.g.
    //   implicit val either2either =
    //     Transformer.derive[Either[Int, Int], Either[String, String]]
    // without it, compilation fails
    // myType2.transformInto[MyType[Either[String, String]]]

    // uses provideMyOtherType(Transformer.derive):
    myOtherType2.transformInto[Either[String, String]]
- if:

  - default values were enabled,
  - source and target had a field defined
  - this field had default value defined
  - macro couldn't derive transformation from source field type to target field type

  Chimney used to use the default value.

  However, this was a buggy behavior, and currently it only uses default values
  if there is no source field nor other fallback or override. Although it is
  a bugfix, it is also a breaking change so it has to be documented. The fix would
  be a manual resolution for all fields which now (correctly) fail due to the bugfix.
